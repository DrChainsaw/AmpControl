package ampcontrol.model.training.model.mutate.reshape;

import lombok.Builder;
import lombok.Setter;
import org.nd4j.linalg.indexing.INDArrayIndex;
import org.nd4j.linalg.indexing.NDArrayIndex;
import org.nd4j.linalg.indexing.SpecifiedIndex;

import java.util.Comparator;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.function.IntUnaryOperator;
import java.util.stream.IntStream;

@Builder(builderClassName = "Builder", buildMethodName = "buildInternal")
public class SingleReshapeSubTask implements ReshapeSubTask {

    private final ReshapeRegistry.ArrayEntry source;
    private final ReshapeRegistry.ArrayEntry target;
    @lombok.Builder.Default
    private final IndMapping sourceIndMapping = IndMapping.builder().build();
    @lombok.Builder.Default
    private final IndMapping targetIndMapping = IndMapping.builder().build();
    private final Function<int[], Comparator<Integer>> compFactory;


    @lombok.Builder(builderClassName = "Builder")
    public static class IndMapping {

        @Setter
        private ReshapeRegistry.ArrayEntry entry;
        @lombok.Builder.Default
        private final IntUnaryOperator dimensionMapper = IntUnaryOperator.identity();
        @lombok.Builder.Default
        private final IntFunction<IntUnaryOperator> remapper = dim -> IntUnaryOperator.identity();

        void addWantedElements(int dim, int[] wantedElementInds) {
            final int mappedDim = dimensionMapper.applyAsInt(dim);
            final INDArrayIndex newIndex = new SpecifiedIndex(IntStream.of(wantedElementInds).map(remapper.apply(mappedDim)).toArray());
            entry.addIndArrayIndex(mappedDim, newIndex);
        }

        void addWantedNrofElements(int dim, int nrofElements) {
            final int mappedDim = dimensionMapper.applyAsInt(dim);
            final INDArrayIndex newIndex = NDArrayIndex.interval(remapper.apply(mappedDim).applyAsInt(0), remapper.apply(mappedDim).applyAsInt(nrofElements));
            entry.addIndArrayIndex(mappedDim, newIndex);
        }
    }

    private void init() {
        sourceIndMapping.setEntry(source);
        targetIndMapping.setEntry(target);
        final long[] shapeSource = source.shape();
        final long[] shapeTarget = target.shape();

        for (int i = 0; i < shapeTarget.length; i++) {
            if (shapeTarget[i] > shapeSource[i]) {
                targetIndMapping.addWantedNrofElements(i, (int) shapeSource[i]);
            }
        }

    }

    @Override
    public void addWantedElements(int dim, int[] wantedElementInds) {
        sourceIndMapping.addWantedElements(dim, wantedElementInds);
    }

    @Override
    public Comparator<Integer> getComparator(int[] tensorDimensions) {
        return compFactory.apply(tensorDimensions);
    }

    @Override
    public void assign() {
        target.put(source);
    }

    public static class Builder {
        // Used through lombok
        private Function<int[], Comparator<Integer>> compFactory = tensorDimensions -> source.defaultComparatorFactory(tensorDimensions);

        // To trick lombok so all boilerplate is done in autogenerated buildInternal
        public SingleReshapeSubTask build() {
            final SingleReshapeSubTask spi = this.buildInternal();
            spi.init();
            return spi;
        }
    }
}
