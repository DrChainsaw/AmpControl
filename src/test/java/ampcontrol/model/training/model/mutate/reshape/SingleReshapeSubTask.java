package ampcontrol.model.training.model.mutate.reshape;

import lombok.Builder;
import lombok.Getter;
import org.nd4j.linalg.api.ndarray.INDArray;
import org.nd4j.linalg.indexing.INDArrayIndex;
import org.nd4j.linalg.indexing.NDArrayIndex;
import org.nd4j.linalg.indexing.SpecifiedIndex;

import java.util.Arrays;
import java.util.Comparator;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.function.IntUnaryOperator;
import java.util.stream.IntStream;

@Builder(builderClassName = "Builder", buildMethodName = "buildInternal")
public class SingleReshapeSubTask implements ReshapeSubTask {

    private final INDArray source;
    private final INDArray target;
    @lombok.Builder.Default
    private final IndMapping sourceIndMapping = IndMapping.builder().build();
    @lombok.Builder.Default
    private final IndMapping targetIndMapping = IndMapping.builder().build();
    private final Function<int[], Comparator<Integer>> compFactory;


    @lombok.Builder(builderClassName = "Builder")
    public static class IndMapping {
        @Getter
        private INDArrayIndex[] inds;
        @lombok.Builder.Default
        private final IntUnaryOperator dimensionMapper = IntUnaryOperator.identity();
        @lombok.Builder.Default
        private final IntFunction<IntUnaryOperator> remapper = dim -> IntUnaryOperator.identity();

        void setDims(int nrofDims) {
            // Should ideally be made in constructor, but then constructor needs to be defined in this and other
            // classes instead of using lombok for this :(
            if (inds != null) {
                throw new IllegalArgumentException("May not reset this!");
            }
            inds = new INDArrayIndex[nrofDims];
            Arrays.fill(inds, NDArrayIndex.all());
        }

        void addWantedElements(int dim, int[] wantedElementInds) {
            final int mappedDim = dimensionMapper.applyAsInt(dim);
            inds[mappedDim] =
                    new SpecifiedIndex(IntStream.of(wantedElementInds).map(remapper.apply(mappedDim)).toArray());
        }

        void addWantedNrofElements(int dim, int nrofElements) {
            final int mappedDim = dimensionMapper.applyAsInt(dim);
            inds[mappedDim] =
                    NDArrayIndex.interval(remapper.apply(mappedDim).applyAsInt(0), remapper.apply(mappedDim).applyAsInt(nrofElements));
        }
    }

    private void init() {
        sourceIndMapping.setDims(source.rank());
        targetIndMapping.setDims(target.rank());
        final long[] shapeSource = source.shape();
        final long[] shapeTarget = target.shape();

        for (int i = 0; i < shapeTarget.length; i++) {
            if (shapeTarget[i] > shapeSource[i]) {
                targetIndMapping.addWantedNrofElements(i, (int) shapeSource[i]);
            }
        }

    }

    @Override
    public void addWantedElements(int dim, int[] wantedElementInds) {
        sourceIndMapping.addWantedElements(dim, wantedElementInds);
    }

    @Override
    public Comparator<Integer> getComparator(int[] tensorDimensions) {
        return compFactory.apply(tensorDimensions);
    }

    @Override
    public void assign() {
        target.put(targetIndMapping.getInds(), source.get(sourceIndMapping.getInds()));
    }

    public static class Builder {
        // Used through lombok
        private Function<int[], Comparator<Integer>> compFactory = tensorDimensions -> (e1, e2) -> -Double.compare(
                source.tensorAlongDimension(e1, tensorDimensions).sumNumber().doubleValue(),
                source.tensorAlongDimension(e2, tensorDimensions).sumNumber().doubleValue());

        // To trick lombok so all boilerplate is done in autogenerated buildInternal
        public SingleReshapeSubTask build() {
            final SingleReshapeSubTask spi = this.buildInternal();
            spi.init();
            return spi;
        }
    }
}
